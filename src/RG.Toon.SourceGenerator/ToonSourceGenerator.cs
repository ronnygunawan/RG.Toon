using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace RG.Toon.SourceGenerator;

[Generator]
public class ToonSourceGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForPostInitialization(postContext =>
        {
            // Add marker attribute
            postContext.AddSource("ToonSerializableAttribute.g.cs", @"
namespace RG.Toon;

/// <summary>
/// Marks a type for source-generated TOON serialization.
/// </summary>
[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Struct, AllowMultiple = false)]
public sealed class ToonSerializableAttribute : System.Attribute
{
}
");
        });

        context.RegisterForSyntaxNotifications(() => new ToonSyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not ToonSyntaxReceiver receiver)
            return;

        foreach (var typeDeclaration in receiver.CandidateTypes)
        {
            var model = context.Compilation.GetSemanticModel(typeDeclaration.SyntaxTree);
            var symbol = model.GetDeclaredSymbol(typeDeclaration);
            
            if (symbol is not INamedTypeSymbol typeSymbol)
                continue;

            // Check if type has ToonSerializable attribute
            var hasToonSerializable = typeSymbol.GetAttributes()
                .Any(ad => ad.AttributeClass?.Name == "ToonSerializableAttribute");

            if (!hasToonSerializable)
                continue;

            var source = GenerateSerializer(typeSymbol);
            context.AddSource($"{typeSymbol.Name}_ToonSerializer.g.cs", source);
        }
    }

    private string GenerateSerializer(INamedTypeSymbol typeSymbol)
    {
        var namespaceName = typeSymbol.ContainingNamespace.IsGlobalNamespace 
            ? null 
            : typeSymbol.ContainingNamespace.ToDisplayString();
        
        var typeName = typeSymbol.Name;
        var properties = GetSerializableProperties(typeSymbol);

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        if (namespaceName != null)
        {
            sb.AppendLine($"namespace {namespaceName};");
            sb.AppendLine();
        }

        sb.AppendLine($"public static class {typeName}ToonSerializer");
        sb.AppendLine("{");
        
        // Generate Serialize method
        GenerateSerializeMethod(sb, typeName, properties);
        
        // Generate Deserialize method
        GenerateDeserializeMethod(sb, typeName, properties);
        
        sb.AppendLine("}");

        return sb.ToString();
    }

    private void GenerateSerializeMethod(StringBuilder sb, string typeName, List<PropertyData> properties)
    {
        sb.AppendLine($"    public static string Serialize({typeName} value, int indentSize = 2)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (value == null) return \"null\";");
        sb.AppendLine("        var sb = new System.Text.StringBuilder();");
        sb.AppendLine("        var indent = new string(' ', 0);");
        
        for (int i = 0; i < properties.Count; i++)
        {
            var prop = properties[i];
            if (i > 0)
            {
                sb.AppendLine("        sb.Append('\\n');");
            }
            sb.AppendLine("        sb.Append(indent);");
            sb.AppendLine($"        sb.Append(\"{prop.ToonName}\");");
            sb.AppendLine("        sb.Append(\": \");");
            sb.AppendLine($"        sb.Append(RG.Toon.ToonSerializer.Serialize(value.{prop.PropertyName}));");
        }
        
        sb.AppendLine("        return sb.ToString();");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private void GenerateDeserializeMethod(StringBuilder sb, string typeName, List<PropertyData> properties)
    {
        sb.AppendLine($"    public static {typeName}? Deserialize(string toon, int indentSize = 2)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (string.IsNullOrEmpty(toon)) return null;");
        sb.AppendLine("        // Use reflection-based deserializer for now");
        sb.AppendLine($"        return RG.Toon.ToonSerializer.Deserialize<{typeName}>(toon, indentSize);");
        sb.AppendLine("    }");
    }

    private List<PropertyData> GetSerializableProperties(INamedTypeSymbol typeSymbol)
    {
        var properties = new List<PropertyData>();

        foreach (var member in typeSymbol.GetMembers())
        {
            if (member is not IPropertySymbol property)
                continue;

            if (!property.CanBeReferencedByName)
                continue;

            if (property.DeclaredAccessibility != Accessibility.Public)
                continue;

            if (property.IsStatic)
                continue;

            // Check for ToonIgnore attribute
            var hasIgnore = property.GetAttributes()
                .Any(ad => ad.AttributeClass?.Name == "ToonIgnoreAttribute");

            if (hasIgnore)
                continue;

            // Get property name (check for ToonPropertyName attribute)
            var nameAttr = property.GetAttributes()
                .FirstOrDefault(ad => ad.AttributeClass?.Name == "ToonPropertyNameAttribute");
            
            var toonName = nameAttr?.ConstructorArguments.FirstOrDefault().Value?.ToString() 
                ?? property.Name;

            properties.Add(new PropertyData(property.Name, toonName));
        }

        return properties;
    }

    private class PropertyData
    {
        public string PropertyName { get; }
        public string ToonName { get; }

        public PropertyData(string propertyName, string toonName)
        {
            PropertyName = propertyName;
            ToonName = toonName;
        }
    }
}

internal class ToonSyntaxReceiver : ISyntaxReceiver
{
    public List<TypeDeclarationSyntax> CandidateTypes { get; } = new List<TypeDeclarationSyntax>();

    public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
    {
        if (syntaxNode is TypeDeclarationSyntax typeDeclaration &&
            typeDeclaration.AttributeLists.Count > 0)
        {
            CandidateTypes.Add(typeDeclaration);
        }
    }
}
